theme: BencV2
title: Future of [ serialization. ]
content: |
  Hello and welcome. In this post, I want to introduce you to BencV2, a **b**inary **enc**oder for blazingly fast serialization and backward/forward compatibility. You need high-performance serialization? Then you're right here.

  > Currently BENC only supports go.

  Anyway, you'll see benchmarks, a quick guide, and performance techniques utilized.

  ### Why BencV2?

  Serialization is important, as in API's, general storage, data transmissions, and much more, though this process may be `slow`, `inefficient` or it just `doesn't meet your performance requirements` when working with JSON, XML, or other serializers. Or you want to encode a third-party struct, but sadly, they used unexported fields? It's possible! ... So I addressed these issues and provided a final solution.

  ### Blazingly Fast Serialization

  One of the primary goals of BencV2 is speed. By using `binary encoding`, `buffer reusing`, and `caching`, BencV2 achieves **zero allocations** as well as **lightning speed**.

  > zero allocations, and lightning speed is only working after the second time of encoding or decoding the same struct (same typeID), because BENC needs to analyze the struct first.

  ### Backward and Forward Compatibility

  Another key feature of BencV2 is its support for backward and forward compatibility. As software systems evolve over time, it's essential that the structure of data is able to change without breaking compatibility with existing data. BencV2 achieves this, like protobuf does.

  For example, you have a simple struct, mark all fields with a `id` tag:

  ````go
  type User struct {
  	ID int `id:"1"`
  	Name string `id:"2"`
  	Age int `id:"3"`
  }
  ````

  Now users have the ability to upload a profile image:

  ````go
  type User struct {
  	ID int `id:"1"`
  	Name string `id:"2"`
  	Age int `id:"3"`
  	ProfileUrl string `id:"4"`
  }
  ````

  There we have the first rule:

  `When adding fields, they need to be placed at the bottom`

  Now the second and last rule, for example:

  ````go
  type User struct {
  	ID int `id:"1"`
  	Name string `id:"2"`
  	Age int `id:"3"`
  }
  ````

  ````go
  type User struct {
  	ID int `id:"1"`
  	// Name string - removed, but now you cannot use the id `2` anymore, and you have to set it as a reserved id in the last param of the `encoder.Encode(&user, 2)` function
  	Age int `id:"3"`
  }
  ````

  This is the rule:

  `When removing fields, the id of the removed field, cannot be reused and has to be marked as reserved`


  ### Benchmarks

  You take a look at some benchmarks comparing BencV2 with other popular serialization formats [here](https://github.com/kinetra/bencv2-benchs).

  ### Quick Guide

  Getting started with BencV2 is easy. Simply import the BencV2 package into your Go project and start encoding and decoding your data.

  Benc (V1 and V2) supports the following types: `string, unsafe string, int 64, int 32, int 16, int 8, uint 64, uint 32, uint 16, uint 8 = byte, float32, float64, bool, map, slice, structs (V2 only) `

  Here's a quick example:

  ````go
  package main

  import (
  	"fmt"
  	benc "github.com/kinetra/bencv2"
  )

  type User struct {
  	ID int
  	Name string
  	Age int
  }

  func main() {
  	user := User{ID: 1, Name: "Alice", Age: 30}

  	// Create a BENC instance; this should be global.
    // 256 is the buffer size
  	encoder := benc.New(256)

  	// Serialize user data
  	encodedData := encoder.Encode(&user)

  	// Deserialize user data
  	var decodedUser User

  	encoder.Decode(encodedData, &decodedUser)
  	fmt.Println("Decoded user:", decodedUser)
  }
  ````

  ### Performance Techniques Utilized

  To achieve its impressive performance, BencV2 employs a variety of optimization techniques, including:

  - Binary encoding: By representing data in binary format rather than text, BencV2 minimizes overhead and reduces serialization time.

  - Buffer Reusing: BencV2 uses buffer reusing, to remove the additional time to allocate a new byte slice.

  - Caching: To correctly encode or decode a struct, BencV2 needs to analyze the fields of the struct, which is inefficient, so by caching the encoding or decoding methods of each field, BencV2 can just skip analyzing the struct.

  In conclusion, BencV2 is a high-performance binary encoder that offers blazingly fast serialization and excellent backward and forward compatibility. If you're looking to optimize the performance of your Go applications, give BencV2 a try. You won't be disappointed!

  ### Plans for the Future

  - **Typescript/JavaScript support**
  - Support for C/C++, as well as Java, Python, C#, and Rust
  - A compiler to generate code for easier forward and backward compatibility

  ### Reporting Issues or Having Ideas

  Please report issues or enhancements in the official `BencV2` GitHub repository.